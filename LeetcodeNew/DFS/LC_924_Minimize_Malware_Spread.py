
"""

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
Example 3:

Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1


https://buptwc.com/2018/10/15/Leetcode-924-Minimize-Malware-Spread/
给定一个图的邻接矩阵和初始点集的数组，问从初始点集中去掉哪个点，
最终从初始点集派生出的最大连通分量包含的点数最小。如果有多个点作用相同，则输出索引最小的点。

现在有一个网络，由邻接矩阵可知其连通性。在网络中，有几个节点被感染，并且会感染与其相连的所有节点。
现在从已知的，最初被感染的节点中去除一个，使网络中被感染的节点达到最小，则应该去除哪个节点。
在做题之前，我们可以先考虑图的组成。对于连通图，也就是一个树，如果存在两个及两个以上的初始感染节点，
那么只有将被感染的节点全部去除，才能使这颗树不被感染，否则，这颗树的节点将全部感染。由此，
可推的非连通图的情况：如果一个连通量中，存在多个被感染的初始节点，那么无论去除哪个初始感染节点，
这个连通量都将被感染。所以，要找寻图中的仅有一个初始感染点且连通量所包含的节点数尽可能大。
---------------------
作者：white_156
来源：CSDN
原文：https://blog.csdn.net/white_156/article/details/83090988
版权声明：本文为博主原创文章，转载请附上博文链接！


Union found all nodes.
Count the union size of each union set.
Count the malware number of each union set.

Return the biggest union's malware if there is one and only one malware.
If no such union that has and has only one malware,
return the malware with minimum index.


分析
定义dfs（index）为深度遍历函数，返回新感染的结点总数，self.gra存储每个结点的感染状态（1为感染，0为未感染）；
dfs从初始结点i开始，遍历所有剩下结点j，若graph[i][j]==1(i,j相连)，则j被感染，以j为初始结点，进入下一层深度遍历，直至所有相连结点都被感染；
遍历initial，即去除当前结点i的感染状态，初始化self.gra，遍历除了i结点外initial中所有结点，作为初始结点，深度遍历，返回新感染的结点个数；
得到返回新感染节点个数最小的对应的去除的结点，即使需要得到的结果；
题目中要求返回最小的结点序号，可以对initial排序之后再处理。

"""

import collections
def minMalwareSpread(self, graph, initial):
    def find(x):
        if x != parents[x]:
            parents[x] = find(parents[x])
        return parents[x]

    def union(x, y):
        parents[find(x)] = find(y)

    # init
    n = len(graph)
    parents = range(n)
    # union
    for i in range(n):
        for j in range(i + 1, n):
            if graph[i][j] == 1:
                union(i, j)
    area = collections.Counter(find(i) for i in range(n))
    malware = collections.Counter(find(i) for i in initial)
    return min(initial, key=lambda i: [(malware[find(i)] == 1) * -area[find(i)], i])

"""
The last line equals to :

        save, res = 0, min(initial)
        for i in initial:
            if malware[find(i)] == 1:
                if area[find(i)] > save:
                    save, res = area[find(i)], i
                elif area[find(i)] == save:
                    res = min(res, i)
        return res
        """


class Solution2:
    def minMalwareSpread(self, graph, initial):
        def dfs(node,vis):
            for v in  range(len(graph[node])):
                if graph[node][v] == 1 and v not in vis:
                    vis.add(v)
                    dfs(v,vis)

        s = set(initial)
        t_vis = set()
        del_node, subgraph_len = min(initial), 0
        for node in range(len(graph)):
            if node not in t_vis:
                vis = set([node])
                dfs(node,vis)
                # 计算子图中感染节点的数量
                infect = vis & s
                if len(infect) == 1:
                    # 长度更长 或者 长度相同但index更小
                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):
                        del_node,subgraph_len = list(infect)[0],len(vis)
                t_vis |= vis
        return del_node


"""

1 1 0   [0, 8]
1 1 0
0 0 1


"""


