"""

https://zhanghuimeng.github.io/post/leetcode-928-minimize-malware-spread-ii/
http://massivealgorithms.blogspot.com/2018/11/leetcode-928-minimize-malware-spread-ii.html


首先我们先将所有的病毒节点去掉，然后将所有连通块合并成一个节点。
这是因为一个连通块中的节点，要么全部被感染，要么全部不被感染，所以我们可以将它们当成一个整体来考虑。
然后我们统计一下所有连通块，直接相邻的病毒节点的个数。
对于一个连通块：
如果直接相邻的病毒节点的个数为0，则一定不会被感染，忽略之；
如果直接相邻的病毒节点的个数为1，则将该病毒节点删除后，整个连通块就可以避免被感染；
如果直接相邻的病毒节点的个数大于等于2，则不管删除哪个病毒节点，该连通块都仍会被感染，忽略之；
所以我们只需在所有第二种连通块（直接相邻的病毒节点的个数为1的连通块）中，找出节点个数最多的连通块，与它相邻的病毒节点就是我们要删除的节点；如果有多个连通块节点个数相同，我们找出与之对应的编号最小的病毒节点即可。
时间复杂度分析：
合并所有非病毒节点的连通块：O(n²）；
统计每个连通块节点的个数：O(n) ；
统计每个连通块连接的病毒节点个数：O(n²）；
遍历所有连通块，求需要删除的节点：O(n) ；


(这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。
一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，
那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。
如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

题意分析：
在图中删除某个结点，使最后受到感染的节点数最小。

这道题关键点在于想到，要想把一个点从本来要被感染的状态变成不被感染，那么需要把能把它感染的结点全部删除！！！
如果一个结点能够被两个或更多感染结点从不同的路径感染，
那么这个结点是不可能安全的。如下图所示，其中黄色结点是初始被感染结点：
对于1结点来说，0,4能从不同的路径将其感染，即使删除一个，另一个也会将其感染。
对于6节点来说，虽然0,4也能将其感染，但是是从相同路径（要经过4），也就是如果我们删除4,即可避免6被感染！

所以我们要找的就是那些只会被一个结点感染的点（如图中的6），然后存储那个唯一可以感染他的结点，
我们采用bfs来完成。如果在bfs过程中遍历到其他被感染结点则不再遍历下去。

最后我们统计存储的结点中哪个结点出现得最多即可，如果都是0则输出index最小的结点

对于1结点来说，0,4能从不同的路径将其感染，即使删除一个，另一个也会将其感染。
对于6节点来说，虽然0,4也能将其感染，但是是从相同路径（要经过4），也就是如果我们删除4,即可避免6被感染！

所以我们要找的就是那些只会被一个结点感染的点（如图中的6），然后存储那个唯一可以感染他的结点，我们采用bfs来完成。如果在bfs过程中遍历到其他被感染结点则不再遍历下去。

最后我们统计存储的结点中哪个结点出现得最多即可，如果都是0则输出index最小的结点

"""

import collections
class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        d = collections.defaultdict(list)
        # 对每个初始感染节点依次bfs，因为节点总数不超过300，所以不会超时
        for init in initial:
            vis = set(initial)
            Q = collections.deque([init])
            while Q:
                infect = Q.popleft()
                for node in range(len(graph[infect])):
                    if graph[infect][node] == 0: continue
                    if node in vis: continue
                    vis.add(node)
                    d[node].append(init)
                    Q.append(node)
        # 统计出现最多次的感染节点
        res = [0] * n
        for key in d:
            if len(d[key]) == 1:
                res[d[key][0]] += 1
        if max(res) == 0: return min(initial)
        return res.index(max(res))



class Solution2:
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.iteritems():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.iteritems():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]



class DSU:
    def __init__(self, N):
        self.p = range(N)
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]


class Solution3:
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        # clean[u] == 1 if its a node in the graph not in initial.
        dsu = DSU(N)
        for u in clean:
            for v in clean:
                if graph[u][v]:
                    dsu.union(u, v)

        # dsu now represents the components of the graph without
        # any nodes from initial.  Let's call this graph G.
        count = collections.Counter()
        node_to_compo = {}
        for u in initial:
            components = set()
            for v in clean:
                if graph[u][v]:
                    components.add(dsu.find(v))
            node_to_compo[u] = components

            for c in components:
                count[c] += 1

        # For each node u in initial, nodeToCompo.get(u)
        # now has every component from G that u neighbors.

        best = (-1, None) # score, node
        for u, components in node_to_compo.iteritems():
            score = 0
            for c in components:
                if count[c] == 1: #uniquely infected
                    score += dsu.size(c)
            if score > best[0] or score == best[0] and u < best[1]:
                best = (score, u)

        return best[1]




